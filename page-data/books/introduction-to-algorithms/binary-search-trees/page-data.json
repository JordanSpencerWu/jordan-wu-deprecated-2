{"componentChunkName":"component---src-templates-book-note-index-tsx","path":"/books/introduction-to-algorithms/binary-search-trees/","result":{"data":{"markdownRemark":{"html":"<p>We can represent such a tree by a linked data structure in which each node is an object. In addition to a <strong>key</strong> and <strong>satellite data</strong>, each node contains attributes <strong>left</strong>, <strong>right</strong>, and <strong>p</strong> that point to the nodes corresponding to its left child, its right child, and its parent, respectively. If a child or the parent is missing, the appropriate attribute contains the value $NIL$. The root node is the only node in the tree whose parent is $NIL$.</p>\n<p>The keys in a binary search tree are always stored in such a way as to satisfy the <strong>binary-search-tree property</strong>:</p>\n<blockquote>\n<p>Let $x$ be a node in a binary search tree. If $y$ is a node in the left subtree of $x$, then $y.key \\leq x.key$. If $y$ is a node in the right subtree of $x$, then $y.key \\geq x.key$.</p>\n</blockquote>\n<p>The binary-search-tree property allow us to print out all the keys in a binary search tree in sorted order by a simple recursive algorithm, called an <strong>inorder tree walk</strong>.</p>\n<p>Given a pointer to the root of the tree and a let $k$, <strong>TREE-SEARCH</strong> returns a pointer to a node with key $k$ if one exists; otherwise, it return $NIL$.</p>\n<h5>TREE-SEARCH x,k</h5>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  <span class=\"token keyword\">if</span> x <span class=\"token operator\">==</span> NIL or k <span class=\"token operator\">==</span> x<span class=\"token punctuation\">.</span>key\n    <span class=\"token keyword\">return</span> x\n  <span class=\"token keyword\">if</span> k <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">.</span>key\n    <span class=\"token keyword\">return</span> TREE<span class=\"token operator\">-</span><span class=\"token function\">SEARCH</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span>k<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> TREE<span class=\"token operator\">-</span><span class=\"token function\">SEARCH</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>k<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Or the iterative algorithm</p>\n<h5>ITERATIVE-TREE-SEARCH x,k</h5>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  <span class=\"token keyword\">while</span> x <span class=\"token operator\">!=</span> NIL and k <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">.</span>key\n    <span class=\"token keyword\">if</span> x <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">.</span>key\n      x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>left\n    <span class=\"token keyword\">else</span> x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>right\n  <span class=\"token keyword\">return</span> x</code></pre></div>\n<p>The procedure begins its search at the root and traces a simple path downward in the tree. For each node $x$ it encounters, it compares the key $k$ with $x.key$. If the two keys are equal, the search terminates. If $k$ is smaller than $x.key$, the search continues in the left subtree of $x$, since the binary-search-tree property implies that $k$ could not be stored in the right subtree. Symmetrically, if $k$ is larger than $x.key$, the search continues in the right subtree. The running time of <strong>TREE-SEARCH</strong> is $\\Theta(h)$, where $h$ is the height of the tree. Use Figure 12.2 in the book for visualization</p>\n<p>We can always find an element in a binary search tree whose key is a minimum by following <em>left</em> child pointers from the root until we encounter a $NIL$.</p>\n<h5>TREE-MINIMUM x</h5>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  <span class=\"token keyword\">while</span> x<span class=\"token punctuation\">.</span>left <span class=\"token operator\">!=</span> <span class=\"token class-name\">NIL</span>\n    x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>left\n  <span class=\"token keyword\">return</span> x</code></pre></div>\n<p>The pseudocode for <strong>TREE-MAXIMUM</strong> is symmetric:</p>\n<h5>TREE-MAXIMUM x</h5>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  <span class=\"token keyword\">while</span> x<span class=\"token punctuation\">.</span>right <span class=\"token operator\">!=</span> <span class=\"token class-name\">NIL</span>\n    x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>right\n  <span class=\"token keyword\">return</span> x</code></pre></div>\n<p>Both run in $\\Theta(h)$, where $h$ is the height of the tree.</p>\n<blockquote>\n<p>We can implement the dynamic-set operations <strong>SEARCH</strong>, <strong>MINIMUM</strong>, <strong>SUCCESSOR</strong>, <strong>PREDECESSOR</strong>, <strong>INSERT</strong>, and <strong>DELETE</strong> so that each one runs in $\\Theta(h)$ time on binary search tree of height $h$.</p>\n</blockquote>","frontmatter":{"author":["Thomas H. Cornmen","And","Charles E Leiserson","And","Ronald L. Riverest","And","Clifford Stein"],"seo_description":"Introduction to Algorithms by Thomas H. Cornmen and Charles E Leiserson and Ronald L. Riverest and Clifford Stein notes.","title":"Binary Search Trees"}}},"pageContext":{"slug":"/books/introduction-to-algorithms/binary-search-trees/"}},"staticQueryHashes":["1584199405","4008572679"]}