{"componentChunkName":"component---src-templates-book-note-index-tsx","path":"/books/javascript-the-good-parts/","result":{"data":{"markdownRemark":{"html":"<p>The very good ideas include functions, loose typing, dynamic objects, and an expressive object literal notation. The bad ideas include a programming model based on global variables.</p>\n<p>The values produced by <code class=\"language-text\">typeof</code> are 'number', 'string', 'boolean', 'undefined',\n'function', and 'object'.</p>\n<p>The <code class=\"language-text\">&amp;&amp;</code> operator produces the value of its first operand if the first operand is falsy. Otherwise, it produces the value of the second operand.</p>\n<p>The <code class=\"language-text\">||</code> operator produces the value of its first operand if the first operand is truthy. Otherwise, it produces the value of the second operand.</p>\n<h5>list of <em>falsy</em> values:</h5>\n<ol>\n<li>false</li>\n<li>null</li>\n<li>undefined</li>\n<li>The empty string ''</li>\n<li>The number 0</li>\n<li>The number NaN</li>\n</ol>\n<p><strong>Note:</strong> All other values are truthy!</p>\n<h5>Objects</h5>\n<p>The simple types of JavaScript are numbers, strings, booleans true and false, null, and undefined. All other values are objects.</p>\n<p>The quotes around a property’s name in an object literal are optional if the name would be a legal JavaScript name and not a reserved word. Values can be retrieved from an object by wrapping a string expression in a [ ] suffix. If the string expression is a constant, and if it is a legal JavaScript name and not a reserved word, then the . notation can be used instead.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">\"first-name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Jordan\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">last_name</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Wu\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\nobject<span class=\"token punctuation\">[</span><span class=\"token string\">\"first-name\"</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// returns Jordan</span>\nobject<span class=\"token punctuation\">.</span>last_name <span class=\"token comment\">// returns Wu</span></code></pre></div>\n<p>Every object is linked to a prototype object from which it can inherit properties. If we try to retrieve a property value from an object, and if the object lacks the property name, then JavaScript attempts to retrieve the property value from the prototype object. And if that object is lacking the property, then it goes to its prototype, and so on until the process finally bottoms out with Object.prototype. Use <code class=\"language-text\">object.hasOwnProperty(variable)</code> to determine whether the property name is truly a member of the object or was found instead on the prototype chain and using <code class=\"language-text\">typeof</code> to exclude functions.</p>\n<p>Objects produced from object literals are linked to Object.prototype. Function objects are linked to Function.prototype which is itself linked to Object.prototype.</p>\n<h5>Functions</h5>\n<p>Objects produced from object literals are linked to Object.prototype. Function objects are linked to Function.prototype which is itself linked to Object.prototype.</p>\n<p>Functions can be defined inside of other functions. An inner function of course has access to its parameters and variables. An inner function also enjoys access to the parameters and variables of the functions it is nested within. The function object created by a function literal contains a link to that outer context. This is called <em>closure</em>.</p>\n<p>In addition to the declared parameters, every function receives two additional parameters: <em>this</em> and <em>arguments</em>. There is no runtime error when the number of arguments and the number of parameters do not match. If there are too many argument values, the extra argument values will be ignored. If there are too few argument values, the undefined value will be substituted for the missing values. There is no type checking on the argument values: any type of value can be passed to any parameter.</p>\n<p><strong>The Method Invocation Pattern</strong> is when a function is stored as a property of an object, we call it a method. When a method is invoked, <em>this</em> is bound to that object. A method can use <em>this</em> to access the object so that it can retrieve values from the object or modify the object.</p>\n<p><strong>The Function Invocation Pattern</strong> is when a function is not the property of an object, then it is invoked as a function. When a function is invoked with this pattern, <em>this</em> is bound to the global object.</p>\n<p>JavaScript is a prototypal inheritance language. <strong>The Constructor Invocation Pattern</strong> is when a function is invoked with the <em>new</em> prefix, then a new object will be created with a hidden link to the value of the function’s prototype member, and <em>this</em> will be bound to that new object. Functions that are intended to be used with the <em>new</em> prefix are called constructors. By convention, they are kept in variables with a capitalized name.</p>\n<p><strong>The Apply Invocation Pattern</strong>, Because JavaScript is a functional object-oriented language, functions can have methods. The <em>apply</em> method lets us construct an array of arguments to use to invoke a function. It also lets us choose the value of <em>this</em>.</p>\n<p>The <em>return</em> statement can be used to cause the function to return early. When <em>return</em> is executed, the function returns immediately without executing the remaining statements. A function always returns a value. If the return value is not specified, then <em>undefined</em> is returned. If the function was invoked with the <em>new</em> prefix and the <em>return</em> value is not an object, then <em>this</em> the new object is returned instead.</p>\n<p>The <em>throw</em> statement interrupts execution of the function. It should be given an exception object containing a <em>name</em> property that identifies the type of the exception, and a descriptive <em>message</em> property.</p>\n<p>JavaScript allows the basic types of the language to be <em>augmented</em>, that adding a method to <code class=\"language-text\">Object.prototype</code> makes that method available to all objects.</p>\n<p><em>Scope</em> in a programming language controls the visibility and lifetimes of variables and parameters. JavaScript does have function scope. That means that the parameters and variables defined in a function are not visible outside of the function, and that a variable defined anywhere within a function is visible everywhere within the function.</p>\n<p>We can use functions and closure to make modules. A module is a function or object that presents an interface but that hides its state and implementation.</p>\n<p>If we have those methods return <em>this</em> instead of undefined, we can enable cascades.</p>\n<p>Functions can use objects to remember the results of previous operations, making it possible to avoid unnecessary work. This optimization is called <em>memoization</em>. JavaScript’s objects and arrays are very convenient for this.</p>\n<h5>inheritance</h5>\n<p>JavaScript is a prototypal language, which means that objects inherit directly from other objects.</p>\n<p><strong>Use Object Specifiers</strong> when a constructor is given a very large number of parameters.</p>\n<p>Prototypal inheritance is conceptually simpler than classical inheritance: a new object can inherit the properties of an old object.</p>\n<p>One weakness of the inheritance patterns we have seen so far is that we get no privacy. All properties of an object are visible.</p>\n<h5>Arrays</h5>\n<p>JavaScript provides an object that has some array-like characteristics. An\narray literal is a pair of square brackets surrounding zero or more values separated by commas. An array literal can appear anywhere an expression can appear. The first value will get the property name '0', the second value will get the property name '1', and so on.</p>\n<p>A common error in JavaScript programs is to use an object when an array is required or an array when an object is required. The rule is simple: when the property names are small sequential integers, you should use an array. Otherwise, use an object.</p>\n<p>JavaScript does not have a good mechanism for distinguishing between arrays and objects. We can work around that deficiency by defining our own is_array function:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">is_array</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    value <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token keyword\">typeof</span> value <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token keyword\">typeof</span> value<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token string\">\"number\"</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token keyword\">typeof</span> value<span class=\"token punctuation\">.</span>splice <span class=\"token operator\">===</span> <span class=\"token string\">\"function\"</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">propertyIsEnumerable</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"length\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>JavaScript provides a set of methods for acting on arrays. The methods are functions stored in Array.prototype.</p>\n<h5>Regular Expression</h5>\n<p>Many of JavaScript’s features were borrowed from other languages. The syntax came from Java, functions came from Scheme, and prototypal inheritance came from Self. JavaScript’s Regular Expression feature was borrowed from Perl.</p>\n<p>Regular expressions are used with methods to search, replace, and extract information from strings. The methods that work with regular expressions are <code class=\"language-text\">regexp.exec</code>, <code class=\"language-text\">regexp.test</code>, <code class=\"language-text\">string.match</code>, <code class=\"language-text\">string.replace</code>, <code class=\"language-text\">string.search</code>, and <code class=\"language-text\">string.split</code>.</p>\n<h5>Methods</h5>\n<p>JavaScript includes a small set of standard methods that are available on the standard types.</p>","frontmatter":{"author":["Douglas Crockford"],"seo_description":"JavaScript - the good parts by Douglas Crockford notes.","title":"JavaScript - The Good Parts"}}},"pageContext":{"slug":"/books/javascript-the-good-parts/"}},"staticQueryHashes":["1584199405","4008572679"]}