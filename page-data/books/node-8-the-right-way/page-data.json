{"componentChunkName":"component---src-templates-book-note-index-tsx","path":"/books/node-8-the-right-way/","result":{"data":{"markdownRemark":{"html":"<p>Node.js's philosophy is to give you low-level access to the event-loop and to system resources.</p>\n<p>Node.js is a single-thread environment, or in other words \"everything runs in parallel except your code.\"</p>\n<p>Event Emitter provides a channel for events to be dispatched and listeners to be notified.</p>\n<p>A Buffer is Nodejs's way of representing binary data. It points to a blob of memory allocated by Nodejs's native code, outside of the JavaScript engine.</p>\n<p>Networked services exist to do two things: connect endpoints and transmit information between them.</p>\n<p>TCP socket connections consist of two endpoints. One endpoint binds to a numbered port while the other endpoint connects to a port.</p>\n<p>A protocol is a set of rules that defines how endpoints in a system communicate.</p>\n<p>Strong convention in the Node community to put supporting code in the lib directory.</p>\n<p>Regular dependencies are used at runtime by your code when you use <code class=\"language-text\">require()</code> to bring in modules. Dev dependences are programs that your project needs during development.</p>\n<h5>Semantic versioning convention:</h5>\n<ol>\n<li>If your code change does not introduce or remove any functionality like a bug fix, then just increment the patch version.</li>\n<li>If your code introduces functionality but doesn't remove or alter existing functionality, then increment the minor version and reset the patch version.</li>\n<li>If your code in any way breaks existing functionality, then increment the major version and reset the minor version and reset the patch version.</li>\n</ol>\n<p>publish/subscribe PUB/SUB EX. The server would publish information in this format, and any number of client programs could subscribe to it.</p>\n<p>request/reply REQ/REP EX. a request comes in, then a reply goes out.</p>\n<p>ROUTER Socket are like parallel REP socket, can handle many requests simultaneously.</p>\n<p>DEALER Socket are like parallel REQ, can send multiple requests in parallel.</p>\n<p>Clustering is a useful technique for scaling up your Node.js application when there's unused CPU capacity available.</p>\n<p>forking creates a worker process running the same scripts as the original.</p>\n<p>Spawning a Child Process works great for executing non-Node.js processes from your Node.js program.</p>\n<p>PUSH and PULL Socket types are useful when you have a queue of jobs that you want to assign among a pool of available workers.</p>\n<p>A message traveling from a PUSH socket to a PULL socket is one-way: the puller can't send a response back through the same socket.</p>\n<p>The practice of compiling source code from one programming language into another or from one language version to another version is called transpiling.</p>","frontmatter":{"author":["Jim R. Wilson"],"seo_description":"Node.js 8 the right way - practical, server-side javascript that scales by Jim R. Wilson notes.","title":"Node.js 8 the Right Way - Practical, Server-Side JavaScript That Scales"}}},"pageContext":{"slug":"/books/node-8-the-right-way/"}}}