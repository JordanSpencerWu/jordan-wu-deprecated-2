{"componentChunkName":"component---src-templates-book-note-index-tsx","path":"/books/understanding-the-four-rules-of-simple-design/","result":{"data":{"markdownRemark":{"html":"<p>Rather than planning for change points, we build systems, by applying simple design principles, that can change easily at ANY point.</p>\n<h5>4 Rules of Simple Design</h5>\n<ol>\n<li>Tests Pass</li>\n<li>Expresses Intent</li>\n<li>No Duplication DRY</li>\n<li>Small</li>\n</ol>\n<h5>Test Names Should Influence Object's API</h5>\n<p>The idea of naming, and how it relates to the intent of your code can seen when looking at the symmetry between test names and the test code. When we write our tests, we should be spending time on our test names.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_a_new_world_is_empty</span></span>\n    world <span class=\"token operator\">=</span> <span class=\"token class-name\">World</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\n    assert_true world<span class=\"token punctuation\">.</span>empty<span class=\"token operator\">?</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_a_cell_can_be_added_to_the_world</span></span>\n    world <span class=\"token operator\">=</span> <span class=\"token class-name\">World</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\n    world<span class=\"token punctuation\">.</span>set_living_at<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    assert_true world<span class=\"token punctuation\">.</span>alive_at<span class=\"token operator\">?</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_after_adding_a_cell_the_world_is_not_empty</span></span>\n    world <span class=\"token operator\">=</span> <span class=\"token class-name\">World</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\n    world<span class=\"token punctuation\">.</span>set_living_at<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    assert_false world<span class=\"token punctuation\">.</span>empty<span class=\"token operator\">?</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>Focusing on the symmetry between a good test name and the code\nunder tests is a subtle design technique.</p>\n<h5>Duplication of Knowledge about Topology</h5>\n<p>A good way to detect knowledge duplication is to ask what happens if we want to change something. What effort is required? How many places will we need to look at and change? A good example from the Conway's Game of Life is to extract the data that represents the location into its own class. This way if you change from two dimensions to three dimensions, you just have to change the <code class=\"language-text\">Location</code> class.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">class</span> <span class=\"token class-name\">Location</span>\n    attr_reader <span class=\"token symbol\">:x</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:y</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">World</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">set_living_at</span></span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">#...</span>\n    <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">alive_at</span></span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">#...</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">LivingCell</span>\n    attr_reader <span class=\"token symbol\">:location</span>\n    <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">DeadCell</span>\n    attr_reader <span class=\"token symbol\">:location</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>This makes the code more adaptable and readable.</p>\n<h4>Behavoir Attractors</h4>\n<p>Whenever we have a new method, a new behavoir, an important question is \"where do we put it?\" What type does this belong to? Imageine we find ourselves in need of asking for the neighbor locations for a given x, y.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">neighbors_of</span></span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># calculate the coordinates of neighbors</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>We can add this method in several places, but the most logical place is in the <code class=\"language-text\">Location</code> class. This class focus on the topology, our behavior is asking for what locations constitute the neighborhood around a given location.</p>\n<blockquote>\n<p>By aggressively eliminating knowledge duplication through reification, we often find that we have built classes that naturally accept new behaviors that arise. They not only accept, but attract them; by the time we are looking to implement a new behavior, there is already a type that is an obvious place to put it.</p>\n</blockquote>\n<h5>Testing State vs Testing Behavoir</h5>\n<p>An alternate way to develop a system is to focus on the behavoir rather than the state of the objects. Think about what behaviors you expect and have our tests center around those. Building our system in a behavior-focused way is about only building the things that are absolutely needed and only at the time they are needed.</p>\n<p>Here's an example from the book:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_a_new_world_is_empty</span></span>\n    assert_true <span class=\"token class-name\">World</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>empty<span class=\"token operator\">?</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token comment\"># this behavior test will help create other tests (above test)</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_an_empty_world_stays_empty_after_a_tick</span></span>\n    world <span class=\"token operator\">=</span> <span class=\"token class-name\">World</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\n    next_world <span class=\"token operator\">=</span> world<span class=\"token punctuation\">.</span>tick\n    assert_true next_world<span class=\"token punctuation\">.</span>empty<span class=\"token operator\">?</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<h5>Don't Have Tests Depend on Previous Tests</h5>\n<p>Looking above at the test case test<em>an</em>empty<em>world</em>stays<em>empty</em>after<em>a</em>tick, the test name indicates we are starting with an empty world, but the test code does not specify this explicitly. There is an assumption here that new worlds are empty, what if we don't start with an empty world?</p>\n<p>The idea of letting the test name influence the test code and use that to make the test code a bit more explicit, let's explicitly ask for an empty world.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_an_empty_world_stays_empty_after_a_tick</span></span>\n    world <span class=\"token operator\">=</span> World<span class=\"token punctuation\">.</span>empty\n      next_world <span class=\"token operator\">=</span> world<span class=\"token punctuation\">.</span>tick\n    assert_true next_world<span class=\"token punctuation\">.</span>empty<span class=\"token operator\">?</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<blockquote>\n<p>The outside world can’t use new to instantiate an object with an expectation of a specific state. Instead, there must be an explicitly named builder method on the class to create an object in a specific, valid state.</p>\n</blockquote>\n<h5>Breaking Abstraction Level</h5>\n<p>In a earlier example, we looked at:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_world_is_not_empty_after_adding_a_cell</span></span>\n    world <span class=\"token operator\">=</span> World<span class=\"token punctuation\">.</span>empty\n    world<span class=\"token punctuation\">.</span>set_living_at<span class=\"token punctuation\">(</span><span class=\"token class-name\">Location</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    assert_false world<span class=\"token punctuation\">.</span>empty<span class=\"token operator\">?</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>We can see that we are testing for a empty world then adding a cell into the empty world. However, looking at the test code, we can see details about the topology: the 1,1. In this case, the test code is implying that the <code class=\"language-text\">empty</code> method is somehow dependent on the coordinates, themselves. To improve this, we hide the details of the topology from the world object.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_world_is_not_empty_after_adding_a_cell</span></span>\n    world <span class=\"token operator\">=</span> World<span class=\"token punctuation\">.</span>empty\n    world<span class=\"token punctuation\">.</span>set_living_at<span class=\"token punctuation\">(</span>Location<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">)</span>\n    assert_false world<span class=\"token punctuation\">.</span>empty<span class=\"token operator\">?</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>By isolating ourselves from changes to the topology, the internals of the Location, we help ensure that this test won’t break if we change something about the underlying coordinate system. You can also use test double.</p>\n<h5>Naive Duplication</h5>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">class</span> <span class=\"token class-name\">Cell</span>\n    attr_reader <span class=\"token symbol\">:alive</span> <span class=\"token comment\"># true | false</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">alive_in_next_generation</span></span><span class=\"token operator\">?</span>\n      <span class=\"token keyword\">if</span> alive\n        number_of_neighbors <span class=\"token operator\">==</span> <span class=\"token number\">2</span> <span class=\"token operator\">||</span> number_of_neighbors <span class=\"token operator\">==</span> <span class=\"token number\">3</span>\n      <span class=\"token keyword\">else</span>\n        number_of_neighbors <span class=\"token operator\">==</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>These 3's are not the same. In our alive case, the 3 is more closely linked to the 2 in the concept of a “stable neighborhood,” while in the dead case, it is linked to something like a “genetically fertile neighborhood.” A good technique is to refactor the conditions into methods.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">class</span> <span class=\"token class-name\">Cell</span>\n    <span class=\"token comment\"># ...</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">alive_in_next_generation</span></span><span class=\"token operator\">?</span>\n      <span class=\"token keyword\">if</span> alive\n        stable_neighborhood<span class=\"token operator\">?</span>\n      <span class=\"token keyword\">else</span>\n        genetically_fertile_neighborhood<span class=\"token operator\">?</span>\n      <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<h5>Procedural Polymorphism</h5>\n<p>Looking at the code above, the <code class=\"language-text\">alive</code> condition isn't a very good choice. Resolving this requires us to talk a bit about polymorphism in general. Polymorphism is about being able to call a method/send a message to an object and have more than one possible behavior. A seemingly quick solution would be to make it something like state and raise it to types: <code class=\"language-text\">LivingCell</code> and <code class=\"language-text\">DeadCell</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">class</span> <span class=\"token class-name\">LivingCell</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">stays_alive</span></span><span class=\"token operator\">?</span>\n      neighbor_count <span class=\"token operator\">==</span> <span class=\"token number\">2</span> <span class=\"token operator\">||</span> neighbor_count <span class=\"token operator\">==</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">DeadCell</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">comes_to_life</span></span><span class=\"token operator\">?</span>\n      neighbor_count <span class=\"token operator\">==</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>A great benefit is that we can add a new state, by adding a new class. We <em>extend</em> our system, rather than modify it.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">class</span> <span class=\"token class-name\">ZombieCell</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">alive_in_next_generation</span></span><span class=\"token operator\">?</span>\n      <span class=\"token comment\"># new, possibly more complex rules</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<h5>Making Assumption About Usage</h5>\n<p>Let's look at the Cell classes.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">class</span> <span class=\"token class-name\">LivingCell</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">stays_alive</span></span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>number_of_neighbors<span class=\"token punctuation\">)</span>\n      number_of_neighbors <span class=\"token operator\">==</span> <span class=\"token number\">2</span> <span class=\"token operator\">||</span> number_of_neighbors <span class=\"token operator\">==</span> <span class=\"token number\">3</span>\n     <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">DeadCell</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">comes_to_life</span></span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>number_of_neighbors<span class=\"token punctuation\">)</span>\n      number_of_neighbors <span class=\"token operator\">==</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>Notice we talking about classes here. A class tend to encapsulate and provide behavoir around state. Methods on them are generally involved in working with that state. In this state the methods are not accessing internal state. Why don’t we reify the idea of a rule? One of the key parts of being easier to change i.e. a better design is being able to more easily find where the changes need to occur; this is what good naming contributes to.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">class</span> <span class=\"token class-name\">LivingCellRules</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">stays_alive</span></span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>number_of_neighbors<span class=\"token punctuation\">)</span>\n      number_of_neighbors <span class=\"token operator\">==</span> <span class=\"token number\">2</span> <span class=\"token operator\">||</span> number_of_neighbors <span class=\"token operator\">==</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">DeadCellRules</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">comes_to_life</span></span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>number_of_neighbors<span class=\"token punctuation\">)</span>\n      number_of_neighbors <span class=\"token operator\">==</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<h5>Unwrapping an Object</h5>\n<p>An example, imagine we have the following two location objects.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">class</span> <span class=\"token class-name\">Location</span>\n    attr_reader <span class=\"token symbol\">:x</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:y</span>\n  <span class=\"token keyword\">end</span>\n\n  location1 <span class=\"token operator\">=</span> <span class=\"token class-name\">Location</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  location2 <span class=\"token operator\">=</span> <span class=\"token class-name\">Location</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">if</span> location1<span class=\"token punctuation\">.</span>equals<span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>location2<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># Do something interesting</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">Location</span>\n    attr_reader <span class=\"token symbol\">:x</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:y</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">equals</span></span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>other_location<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">==</span> other_location<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">==</span> other_location<span class=\"token punctuation\">.</span>y\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>This <code class=\"language-text\">equals?</code> method doesn’t conform to our constraint: it is asking other_location to return its x and y. This isn’t allowed. A technique that call unwrapping, follows alternate form of equals.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">  <span class=\"token keyword\">class</span> <span class=\"token class-name\">Location</span>\n    attr_reader <span class=\"token symbol\">:x</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:y</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">equals</span></span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>other_location<span class=\"token punctuation\">)</span>\n      other_location<span class=\"token punctuation\">.</span>equals_coordinate<span class=\"token operator\">?</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">equals_coordinate</span></span><span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>other_x<span class=\"token punctuation\">,</span> other_y<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">==</span> other_x <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">==</span> other_y\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span></code></pre></div>\n<p>This new form of equals only allows the object access to it's own states. The section goes deeper into a constraints in coderetreat is writing your code with “no return values.”</p>\n<h5>Inverted Composition as a Replacement for Inheritance</h5>\n<p>Inheritance is often used as way of creating “reuse” rather than eliminating duplication.</p>","frontmatter":{"author":["Corey Haines"],"seo_description":"Understanding the 4 rules of simple design by Corey Haines notes.","title":"Understanding The 4 Rules Of Simple Design"}}},"pageContext":{"slug":"/books/understanding-the-four-rules-of-simple-design/"}},"staticQueryHashes":["1584199405","4008572679"]}