{"componentChunkName":"component---src-templates-book-note-index-tsx","path":"/books/clean-architecture/","result":{"data":{"markdownRemark":{"html":"<p>When software is done right, it requires a fraction of the human resources to create and maintain. Changes are simple and rapid.</p>\n<p>The goal of software architecture is to minimize the human resources required to build and maintain the required system.</p>\n<p>Making messes is always slower than staying clean.</p>\n<p>Every software system provides two different values to the stakeholders: behavior and structure.</p>\n<p>The first value of software is its behavior. Programmers are hired to make machines behave in a way that makes or saves money for the stakeholders.</p>\n<p>The second value of software is, it must be easy to change. When the stakeholders change their minds about a feature, that change should be simple and easy to make.</p>\n<p>Just remember: If architecture comes last, then the system will become ever more costly to develop, and eventually change will become practically impossible for part or all of the system.</p>\n<p>Paradigms are ways of programming, relatively unrelated to languages. A paradigm tells you which programming structures to use, and when to use them.</p>\n<p>Structured programming imposes discipline on direct transfer of control.</p>\n<p>Object-oriented programming imposes discipline on indirect transfer of control.</p>\n<p>Functional programming imposes discipline upon assignment.</p>\n<p>Each of the paradigms removes capabilities from the programmer.</p>\n<p>We use polymorphism as the mechanism to cross architectural boundaries; we use functional programming to impose discipline on the location of and access to data; and we use structured programming as the algorithmic foundation of our modules. Notice how well those three align with the three big concerns of architecture: function, separation of components, and data management.</p>\n<p>Structured programming allows modules to be recursively decomposed into provable units, which in turn means that modules can be functionally decomposed.</p>\n<p>\"Testing shows the presence, not the absence, of bugs\"</p>\n<p>Structured programming forces us to recursively decompose a program into a set of small provable functions. We can then use test to try to prove those small provable function incorrect. If such test fails to prove incorrectness, then we deem the functions to be correct enough for our purposes.</p>\n<p>The fact that OO languages provide safe and convenient polymorphism means that any source code dependency, no matter where it is, can be inverted. Any source code dependencies can be turned around by inserting an interface between them. Dependency Inversion</p>\n<p>Software architects working in system written in OO languages have absolute control over the direction of all source code dependencies in the system.</p>\n<p>All race conditions, deadlock conditions, and concurrent condition or a concurrent update problem are due to mutable variables.</p>\n<h5>Single Responsibility Principle SRP</h5>\n<p>Software systems are changed to satisfy a group of one or more people, we'll refer to them as an actor and are the \"reason to change.\"</p>\n<p>A module should be responsible to one, and only one, actor.</p>\n<h5>Open-Closed Principle OCP</h5>\n<p>A software artifact should be open for extension but closed for modification.</p>\n<p>If component <strong>A</strong> should be protected from changes in component <strong>B</strong>, then component <strong>B</strong> should depend on component <strong>A</strong>.</p>\n<h5>Liskov Substitution Principle LSP</h5>\n<p>If for each object <strong>o1</strong> of type <strong>S</strong> there is an object <strong>o2</strong> of type <strong>T</strong> such that for all programs <strong>P</strong> defined in terms of <strong>T</strong>, the behavior of <strong>P</strong> is unchanged when <strong>o1</strong> is substituted for <strong>o2</strong> then <strong>S</strong> is a subtype of <strong>T</strong>.</p>\n<h5>Interface Segregation Principle ISP</h5>\n<p>It is harmful to depend on modules that contain more than you need.</p>\n<h5>Dependency Inversion Principle DIP</h5>\n<p>The most flexible system are those in which source code dependencies refer only to abstraction, not to concretions.</p>\n<p>It is the volatile concrete element of our system that we want to avoid depending on, therefore interfaces are less volatile than implementations.</p>\n<p>Components are the units of deployment, they are the smallest entities that can be deployed as part of a system.</p>\n<p>A directed acyclic graph DAG: Regardless of which component you begin at, it is impossible to follow the dependency relationships and wind up back at that component.</p>\n<p>Stability is related to the amount of work required to make a change.</p>\n<p>One way to determine the stability of a component is to count the number of dependencies that enter and leaves that component.</p>\n<p>Fan-in: Incoming dependencies</p>\n<p>Fan-out: Outgoing dependencies</p>\n<p>Instability <strong>I</strong>: <strong>I</strong> = Fan-out รท Fan-in + Fan-out</p>\n<p><strong>I</strong> = 0 indicates a maximally stable component. <strong>I</strong> = 1 indicates a maximally unstable component.</p>\n<p>The changeable component are on top and depend on the stable component at the bottom. The <strong>I</strong> metrics should decrease in the direction of dependency.</p>\n<p>Stable Abstraction Principle SAP: A stable component should also be abstract so that its stability does not prevent it from being extended. An unstable component should be concrete since its instability allows the concrete code within it to be easily changed.</p>\n<p>Good architecture makes the system easy to understand, easy to develop, easy to maintain, and easy to deploy.</p>\n<p>Arranging our systems into a plugin architecture creates firewalls across which changes cannot propagate.</p>\n<p>Dependency arrows are arranged to point from lower-level details to higher-level abstractions.</p>\n<p>Business rules are rules or procedures that make or save the business money.</p>\n<p>An Entity is an object within our computer system that embodies a small set of critical business rules operating on Critical Business Data.</p>\n<p>A use case is a description of the way that an automated system is used. It specifies the input to be provided by the user, the output to be returned to the user, and the processing steps involved in producing that output.</p>\n<p>Good architectures are centered on use cases so that architects can safely describe the structures that support those use cases without committing to frameworks, tools, and environments.</p>\n<p>Dependency Rule: Source code dependencies must point only inward, toward higher-level policies.</p>\n<p>The Humble Object pattern is a design pattern that was originally identified as a way to help unit testers to separate behaviors that are hard to test from behaviors that are easy to test.</p>\n<p>Database gateways are polymorphic interfaces that contain methods for every create, read, update, or delete operation that can be performed by the application on the database.</p>\n<p>Data mapper load data into data structures from relational database tables.</p>\n<p>Think of Main as a plugin to the application - a plugin that sets up the initial conditions and configurations, gathers all the outside resources, and then hands control over to high-level policy of the application.</p>\n<p>Test are the most isolated system component, nothing within the system depends on tests, and the tests always depend inward on the components of the system.</p>\n<p>First make it work, then make it right, then make it fast.</p>","frontmatter":{"author":["Robert C. Martin"],"seo_description":"Clean architecture - a craftsman's guide to software structure and design by Robert C. Martin notes.","title":"Clean Architecture - A Craftsman's Guide To Software Structure And Design"}}},"pageContext":{"slug":"/books/clean-architecture/"}},"staticQueryHashes":["1584199405","4008572679"]}