{"data":{"markdownRemark":{"html":"<p>An <strong>algorithm</strong> is a sequence of computational steps that transform the input into the output. <strong>Analyzing</strong> an algorithm has come to mean predicting the resources that the algorithm requires. The time taken by an algorithm grows with the size of the input, so it is traditional to describe the running time of a program as a function of the size of its input. To do so, we need to define the terms \"running time\" and \"size of input\" more carefully.</p>\n<p><strong>Input size</strong> depends on the problem being studied. For many problems the <em>number of items in the input</em>, or it may be <em>total numbers of bits</em> needed to represent the input in ordinary binary notation.</p>\n<p><strong>Running time</strong> of an algorithm on a particular input is the number of primitive operations or \"steps\" executed.</p>\n<p>For the most part of the book, the focus will be on the <strong>worst-case running time</strong>, the longest running time for <em>any</em> input of size $n$. The reason why is this running time gives us the upper bound on the running time for any input of size $n$ guarantee that the algorithm will never take any longer.</p>\n<p><strong>Rate of growth</strong> or <strong>order of growth</strong> of the running time, we consider only the leading term of the running time function and also ignore the leading term's constant coefficient.</p>\n<p>We use <strong>loop invariants</strong> to help us understand why an algorithm is correct, it must satisfy the following conditions:</p>\n<p><strong>Initialization</strong>: It is true prior to the first iteration of the loop.</p>\n<p><strong>Maintenance</strong>: If it is true before an iteration of the loop, it remains true before the next iteration.</p>\n<p><strong>Termination</strong>: When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct.</p>\n<p>A <strong>median</strong>, informally, is the \"halfway point\" of the set. When $n$ is odd, the median is unique, occuring at $i = (n + 1) / 2$. When $n$ is even, there are two medians, occurring at $i = n / 2$ and $i = n / 2 + 1$.</p>","frontmatter":{"author":["Thomas H. Cornmen","And","Charles E Leiserson","And","Ronald L. Riverest","And","Clifford Stein"],"seo_description":"Introduction to Algorithms by Thomas H. Cornmen and Charles E Leiserson and Ronald L. Riverest and Clifford Stein notes.","title":"Introduction to Algorithms"}},"allMarkdownRemark":{"edges":[{"node":{"id":"255f1ad5-a0b7-5e95-b75d-fedf461e2f47","fields":{"slug":"/books/introduction-to-algorithms/counting-sort/"}}},{"node":{"id":"92e8b0b5-97b3-567f-9244-dc937c72b148","fields":{"slug":"/books/introduction-to-algorithms/hash-tables/"}}},{"node":{"id":"5b4ed3a6-531d-5def-afcf-78b895fa2c4b","fields":{"slug":"/books/introduction-to-algorithms/bubble-sort/"}}},{"node":{"id":"25e6b927-a0b9-5a3d-a041-e900cd5e0af6","fields":{"slug":"/books/introduction-to-algorithms/binary-search-trees/"}}},{"node":{"id":"4497e5e5-742e-517b-b9ec-5bfad944011f","fields":{"slug":"/books/introduction-to-algorithms/heap/"}}},{"node":{"id":"c1970163-fbc9-5558-9adc-aa4c528bf31f","fields":{"slug":"/books/introduction-to-algorithms/heap-sort/"}}},{"node":{"id":"17416940-c031-5641-a3c8-70d0975f79f2","fields":{"slug":"/books/introduction-to-algorithms/intro-to-data-structure/"}}},{"node":{"id":"5e56b1d6-fcc3-55a5-bc7f-2168770f2926","fields":{"slug":"/books/introduction-to-algorithms/insertion-sort/"}}},{"node":{"id":"e2f1d159-8fc7-521c-b700-0eb49b66ef33","fields":{"slug":"/books/introduction-to-algorithms/linked-lists/"}}},{"node":{"id":"0abc927b-ba54-5232-88ee-87ddb87868d7","fields":{"slug":"/books/introduction-to-algorithms/min-heap/"}}},{"node":{"id":"d5bf7e82-e686-5d5b-84de-c6db2d2232d6","fields":{"slug":"/books/introduction-to-algorithms/max-heap/"}}},{"node":{"id":"9d659dd9-0d4e-5341-bd5b-247abcf80e67","fields":{"slug":"/books/introduction-to-algorithms/quicksort/"}}},{"node":{"id":"cce90b1c-d768-5028-8de8-41239b991f0d","fields":{"slug":"/books/introduction-to-algorithms/merge-sort/"}}},{"node":{"id":"90bc0b32-9200-5085-b65f-f22f916cddaf","fields":{"slug":"/books/introduction-to-algorithms/priority-queues/"}}},{"node":{"id":"7b0317f4-306a-5d3a-95bb-e09b94d71a54","fields":{"slug":"/books/introduction-to-algorithms/radix-sort/"}}},{"node":{"id":"5777b248-7591-583b-a4d2-e84707d68938","fields":{"slug":"/books/introduction-to-algorithms/stacks/"}}},{"node":{"id":"c0d71e28-8103-5128-a104-fdc3e1827d87","fields":{"slug":"/books/introduction-to-algorithms/randomized-quicksort/"}}},{"node":{"id":"1ae8a3eb-1a84-5048-b5d7-98fbb96836eb","fields":{"slug":"/books/introduction-to-algorithms/selection-sort/"}}},{"node":{"id":"a3b7d244-1219-5c96-b7a0-a2a307ba986d","fields":{"slug":"/books/introduction-to-algorithms/queues/"}}}]}}}